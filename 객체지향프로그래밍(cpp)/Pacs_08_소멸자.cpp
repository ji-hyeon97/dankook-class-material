/*
소멸자

객체가 소멸되는 시점 : 함수 내에 지역적으로 변수가 선언되면 함수 호출이 끝남과 동시에 소멸이 된다
이와 마찬가지로 객체도 함수내에서 선언된다고 하면, 함수 호출이 끝나면 소멸하게 된다.

전역적으로 선언된 객체 : 전역변수는 프로그램 시작과 동시에 메모리에 올라갔다가, 프로그램이 종료될때
소멸된다. 객체도 마찬가지로 똑같은 동작을 하지만, 객체는 이렇게 생성할 일은 거의 없다고 보면 된다

전역 : 일반적인 객체지향에 전역이란 개념은 존재하지 않는다. 이를 대신하기 위해 static 멤버 변수, 멤버 함수가 존재한다.

소멸자 : 객체의 메모리 반환을 위해서 객체 소멸시 자동 호출되는 함수로 클래스의 이름 앞에는 ~가
붙은 형태를 띄우며, 리턴하지 않고, 리턴 타입도 없다. 전달인자는 항상 Void형으로 오버로딩, 디폴트 매개변수의 선언이
불가능하다는 특징을 가지고 있다. 그럼 아래의 동적 할달 예제를 통해서 소멸자가 어떻게 동작하고 있는지 알아 보자
*/

#include<iostream>

using namespace std;

class DynamicArray {
public:
	int *arr;

	DynamicArray(int arraySize) {
		arr = new int[arraySize]; //인자로 받는 크기만큼 메모리를 할당한다.
	}

	//소멸자, 메모리를 해제한다.
	~DynamicArray() {
		delete[] arr;
		arr = NULL;
	}
};

int main() {
	int size;
	int i;
	cout << "몇개의 정수를 입력하겠는가 ? " << endl;
	cin >> size;
	
	DynamicArray da(size);

	cout << size << "개의 정수를 입력 하시오. " << endl;
	
	for (i = 0; i < size; i++) {
		cin >> da.arr[i];
	}

	for (i = size - 1; i >= 0; i--) {
		cout << da.arr[i] << " ";
	}

	cout << endl;

	return 0;
}
/*
DynamicArray 클래스는 내부적으로 동적 메모리 할당을 사용한다. 41번째 줄에서 DynamicArray 타입의 객체 da를 생성하면서
필요한 메모리의 크기를 인자로 전달하는데, 10번째 줄처럼 메모리를 동적으로 할당하고 그 주소를 arr
멤버 변수에 보관해준다. 아마 DynamicArray를 생성하면 아래와 같은 모습을 띄고 있을 것이다.

결국 main() 함수가 끝나면 da 객체가 자동적으로 소멸하게 된다. 함수 안에서 정의한 변수는 함수가 종료와 동시에 소멸되므로,
객체가 소멸하면서 자동적으로 소멸자가 호출되고, 30번째 줄처럼 소멸자 안에서 arr이 가르키는 메모리를 해제 한다. 만약 
소멸자가 없었다 라고 한다면, 우리는 클래스를 만들고 프로그램을 짤때마다 일일히 다 해제를 해주어야 한다 만약 프로그램의
크기가 커진다고 생각하면, 참 큰일이 아닐수 없다.

객체의 소멸순서 : 객체의 소멸 순서는 소멸자 호출 -> 메모리 반환 순서로 객체가 소멸되고, 소멸자의 호출을 먼저 해주는 
이유는 소멸자의 호출을 먼저 해줌으로서, 메모리가 반환되어질때, 반환되어지지 않는 메모리 공간을 명시적으로 반환해주기
위해서이다.

기본적으로 소멸자를 명시해주지 않아도 디폴트 소멸자가 사용되고, 디폴트 소멸자는 디폴트 생성자와 같은 특징을 가지고 있다.
소멸자의 명시적 제공은 첫번째, 생성자에서 메모리를 동적으로 할당하는 경우나 디버깅시 사용자가 객체의 소멸되는 시점을 알고
싶을때 사용을 한다
*/